<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>elisr companion • elisr</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/yeti/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="elisr companion">
<meta property="og:description" content="elisr">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">elisr</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">0.1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/elisr.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/sbissantz/elisr/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="elisr_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>elisr companion</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/sbissantz/elisr/blob/master/vignettes/elisr.Rmd"><code>vignettes/elisr.Rmd</code></a></small>
      <div class="hidden name"><code>elisr.Rmd</code></div>

    </div>

    
    
<div id="exploratory-likert-scaling-in-r" class="section level3">
<h3 class="hasAnchor">
<a href="#exploratory-likert-scaling-in-r" class="anchor"></a>Exploratory Likert Scaling in R</h3>
<p><code>elisr</code> is a shorthand for Exploratory Likert Scaling (ELiS) in R. ELiS is a multiple one-dimensional scaling approach and operates on a bottom-up selection process that integrates characteristic values of classical test theory. This technical companion is a step-by-step approach on how to use <code>elisr</code>. At the end of this manual, you will have gained enough understanding to confidently perform analysis in this framework. By working through the following examples, you will not only grasp what is going on under the hood, but also encounter some benefits of this approach. Note however, that this is mainly thought as a manual. For a more complete view on the heuristic potential that lays out with this approach, you might want to take a look in the cited paper, too. There is at least one article [in progress] which is not yet mentioned. I will update the list of articles as soon as possible.</p>
</div>
<div id="important-note" class="section level3">
<h3 class="hasAnchor">
<a href="#important-note" class="anchor"></a>Important note</h3>
<p>It cannot be stressed often enough, that after exploring your data set with <code><a href="../reference/disjoint.html">disjoint()</a></code> and <code><a href="../reference/overlap.html">overlap()</a></code> you need to process the result. Additional analysis is essential. You can find a way to proceed (with a follow-up analysis) in the last section. Alright, let’s ease up and dive deeper into some of <code>elisr</code>’s fiddly technical details.</p>
</div>
<div id="welcome-disjoint-overlap" class="section level2">
<h2 class="hasAnchor">
<a href="#welcome-disjoint-overlap" class="anchor"></a>Welcome <code>disjoint()</code> &amp; <code>overlap()</code>
</h2>
<p><code>elisr</code> basically consists of two user functions <code><a href="../reference/disjoint.html">disjoint()</a></code> and <code><a href="../reference/overlap.html">overlap()</a></code>. With a typical case in mind, the practical difference between them is: (1) <code><a href="../reference/disjoint.html">disjoint()</a></code> is set up to produce sharp and disjoint scale fragments. Sharp and disjoint fragments feature a high internal consistency. Thus, items within such a fragment share a strong linear relationship with each another. The thing with <code><a href="../reference/disjoint.html">disjoint()</a></code> is, it allocates any item to a particular fragment. This is where (2) <code><a href="../reference/overlap.html">overlap()</a></code> steps in. Passing fragments to <code><a href="../reference/overlap.html">overlap()</a></code>, the function’s underlying algorithm tries to enrich each fragment. The emerging scales are flavored with items from your specified data frame, but the algorithm ignores those that are already built into a fragment. We will talk about the inclusion criterion later in much greater detail. To get to the point: Using <code><a href="../reference/overlap.html">overlap()</a></code> an item can appear in more than one of the enriched fragments. In doing so, we overcome the splitting effect <code><a href="../reference/disjoint.html">disjoint()</a></code> induces. These basic principles unfold one step at a time throughout the rest of this companion. So, stay tuned!</p>
<blockquote>
<p><strong>Spoiler alert</strong>: Let me tempt you with this; the last section did already reveal the key strategy of an exploratory scale analysis using <code>elisr</code>. If you consult the bottom-up item-selection procedure for advice, you will often find yourself following these two steps: (1) Instruct <code><a href="../reference/disjoint.html">disjoint()</a></code> to produce a couple of sharp, disjoint scale fragments. (2) Let <code><a href="../reference/overlap.html">overlap()</a></code> pick up (and expand) the pieces to complete the scales.</p>
</blockquote>
<div id="a-primer-for-monitoring-the-scale-developement-process" class="section level3">
<h3 class="hasAnchor">
<a href="#a-primer-for-monitoring-the-scale-developement-process" class="anchor"></a>A primer for monitoring the scale developement process</h3>
<p>In preparation for the upcoming analyses, I want to loose a word about how <code>elisr</code> keeps track of the development process of a scale. There are 3 monitoring devices: <code>mrit</code>, <code>alpha</code>, and <code>rbar</code>. <code>mrit</code> stands for “<em>marginal</em> corrected item-total correlation”. <code>mrit</code> displays the linear relationship between the sum score of the items in a fragment <em>at some specific point of the scale development process</em> and an item which is considered for admission. I use a part-whole-correction to compute this value. So, the item (which is considered for admission) is not part of the sum score. If this does not make sense right now, hang on. A lot about this is said in later chapters or in the references. But start with <code><a href="../reference/print.msdf.html">?print.msdf</a></code>. All right, let’s move on. The marginal part (italic) applies for <code>alpha</code> and <code>rbar</code>, too. But “Cronbach’s alpha” (<code>alpha</code>) gauges the internal consistency of a scale whereas <code>rbar</code> tracks the average inter-item correlation. That is basically it. Now, we can start analyzing the <code>trust</code> items.</p>
</div>
</div>
<div id="analyzing-the-trust-items" class="section level2">
<h2 class="hasAnchor">
<a href="#analyzing-the-trust-items" class="anchor"></a>Analyzing the trust items</h2>
<p>Let’s jump right into practice. <code>trust</code> is going to be the data base in the upcoming units. <code>trust</code> is a subset of the German General Social Survey (ALLBUS) 2018 in which participants answered a couple of questions on their trust in public institutions and organizations (type <code><a href="../reference/trust.html">?trust</a></code>). Because the data frame is already built into <code>elisr</code>, we have easy access to it.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/sbissantz/elisr">elisr</a></span><span class="op">)</span> ; <span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">trust</span><span class="op">)</span> ; <span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">trust</span><span class="op">)</span>
<span class="co">#&gt; Welcome to elisr!</span>
<span class="co">#&gt;   healserv fccourt bundtag munadmin judsyst tv newsppr uni fedgovt police</span>
<span class="co">#&gt; 1        6       7       5        5       3  7       6   4       5      5</span>
<span class="co">#&gt; 2        5       5       4        5       3  3       4   5       2      5</span>
<span class="co">#&gt; 3        6       6       6        3       6  4       4   5       6      5</span>
<span class="co">#&gt; 4        6       4       3        3       3  1       1   3       3      3</span>
<span class="co">#&gt; 5        5       1       1        4       2  1       1   5       1      2</span>
<span class="co">#&gt; 6        5       5       5        7       4  4       3   4       6      7</span>
<span class="co">#&gt;   polpati eucomisn eupalmnt</span>
<span class="co">#&gt; 1       4        3        4</span>
<span class="co">#&gt; 2       1        4        4</span>
<span class="co">#&gt; 3       5        4        4</span>
<span class="co">#&gt; 4       3        3        3</span>
<span class="co">#&gt; 5       1        1        1</span>
<span class="co">#&gt; 6       4       NA        5</span></code></pre></div>
<p>Great. The output shows the first six values of each variable of the <code>trust</code> data set. But since we want to have a look under <code>elisr</code>’s hood, we should get the machinery working. First, we inspect <code><a href="../reference/disjoint.html">disjoint()</a></code> and then move on to <code><a href="../reference/overlap.html">overlap()</a></code>.</p>
<div id="disjoint" class="section level3">
<h3 class="hasAnchor">
<a href="#disjoint" class="anchor"></a>disjoint()</h3>
<p>In the following snippets, we will use a disjoint scaling procedure to produce a couple of sharp fragments. For that reason, we consult <code><a href="../reference/disjoint.html">disjoint()</a></code>. Using <code><a href="../reference/disjoint.html">disjoint()</a></code> we will first smash the data set to smithereens. Therefore, we need to learn about <code>mrit_min</code>. After that, we will talk a little bit about the thing you have produced, a <code>msdf</code>. Then, we go over some terminology, and finally talk a little more about the output itself.</p>
<div id="mrit_min" class="section level4">
<h4 class="hasAnchor">
<a href="#mrit_min" class="anchor"></a>mrit_min</h4>
<p>To smash the scale (and produce the desired sharp fragments), we set up <code><a href="../reference/disjoint.html">disjoint()</a></code> with a high value for the <em>marginal corrected item-total correlation</em> <code>mrit_min</code>. Think of <code>mrit_min</code> as definition of a fragment’s lower boundary. It comes in the form of a correlation ranging between 0 and 1 (see <code><a href="../reference/disjoint.html">?disjoint</a></code>). So below this value you are not willing to accept an item to be integrated into any of the emerging fragments. One could also say, you forbid <code><a href="../reference/disjoint.html">disjoint()</a></code> to incorporate such items. All right, let’s put things into practice. Because <code>mrit_min = 0.55</code> produced satisfactory results in some of my own prior analyses I will stick with it for now. But feel free to play around with this value (to fully understand its behavior).</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># `(foo &lt;- baz)`: assign and print in one step</span>
<span class="op">(</span><span class="va">msdf</span> <span class="op">&lt;-</span>  <span class="fu"><a href="../reference/disjoint.html">disjoint</a></span><span class="op">(</span>df <span class="op">=</span> <span class="va">trust</span>, mrit_min <span class="op">=</span> <span class="fl">0.55</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67   0.8</span></code></pre></div>
</div>
<div id="msdf" class="section level4">
<h4 class="hasAnchor">
<a href="#msdf" class="anchor"></a>msdf</h4>
<p>The above output shows summary statistics of a multiple scaled data frame (<code>msdf</code>). Think of <code>msdf</code>s as named <code>list</code>s extended with a couple of attributes for internal computational reasons (see <code><a href="https://rdrr.io/r/base/attributes.html">attributes(msdf)</a></code>). If you cannot see the output I am currently talking about, something went wrong. If everything ran smoothly you can skip the <strong>Help &amp; Advice</strong> section to continue.</p>
<blockquote>
<p><strong>Help &amp; Advice</strong>: Okay, something went wrong. First of all,<code><a href="../reference/disjoint.html">disjoint()</a></code> (and <code><a href="../reference/overlap.html">overlap()</a></code>) actually complain about quite a number of things. Hopefully, the provided messages are sensible enough to let you cope with the particular obstacle. So, if a brilliant orange advice shines out of your console, read the message carefully (and try to follow instructions). My first guess would always be a typo. These little goblins are nasty everyday companions in applied research. But if you cannot encrypt the error message, hack it into Google.</p>
</blockquote>
<p>Done? Alright, then we can go over to the terminology part and then learn something more about <code><a href="../reference/disjoint.html">disjoint()</a></code>’s machinery.</p>
</div>
<div id="some-terminology" class="section level4">
<h4 class="hasAnchor">
<a href="#some-terminology" class="anchor"></a>Some terminology</h4>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">msdf</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67   0.8</span></code></pre></div>
<p>Focus on <code>$scl_1</code>. I will refer to objects like <code>scl_1</code> (read as: scale one) generally, as fragments. Now take a closer look at <code>eupalmnt</code>, <code>eucomisn</code> (read as: EU Parliament &amp; EU Commission). This comma-separated pair of two items in the first line is the core of <code>scl_1</code>. The core highlights the result of the first step of the scaling procedure – a two-item scale. As we can see, the core of <code>scl_1</code> contains the two variables that share the highest positive linear association in the data frame (<code>mrit = rbar = 0.92</code>). To find it, <code><a href="../reference/disjoint.html">disjoint()</a></code> (and <code><a href="../reference/overlap.html">overlap()</a></code>) sets up a correlation matrix internally and asks for the one (correlation) that is the highest of them all.</p>
<blockquote>
<p><strong>Note</strong>: If multiple pairs share the same positive linear relationship, <code><a href="../reference/disjoint.html">disjoint()</a></code> will always choose the first one in order.</p>
</blockquote>
<p>It is important to mention, that in search of the highest correlation neither <code><a href="../reference/disjoint.html">disjoint()</a></code> nor <code><a href="../reference/overlap.html">overlap()</a></code> will go on forever. To become a bit more precise, both functions give up the search, when the data frame lacks a correlation that exceeds your preset <code>mrit_min</code>. For convenience, <code><a href="../reference/disjoint.html">disjoint()</a></code> owns a test function for this purpose. If you want to try it out type <code><a href="../reference/disjoint.html">disjoint(trust, mrit_min=.95)</a></code></p>
</div>
<div id="under-disjoints-hood" class="section level4">
<h4 class="hasAnchor">
<a href="#under-disjoints-hood" class="anchor"></a>Under disjoint()’s hood</h4>
<p>In the prior analysis, however, everything ran smoothly. So let’s put this result back on the screen and refocus on the algorithm again. We were looking for the highest correlation which sets up the core. To simplify the forthcoming procedure, remember our previous <code>mrit_min = 0.55</code>.</p>
<blockquote>
<p><strong>Note</strong>: If the value of <code>mrit_min</code> slipped your mind, read out <code>msdf</code>’s attributes as a remainder (type <code><a href="https://rdrr.io/r/base/attributes.html">attributes(msdf)</a></code>)</p>
</blockquote>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">msdf</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67   0.8</span></code></pre></div>
<p>In the first line we can see that the core consists of <code>eupalmnt</code> and <code>eucomisn</code>. As mentioned above, both variables share the highest correlation (which is obviously greater than our prespecefied <code>mrit_min = 0.55</code>): <code>mrit = 0.92</code>. But once the core was found, what happened to <code>scl_1</code> ? Let’s throw a quick glance under <code><a href="../reference/disjoint.html">disjoint()</a></code>’s hood:</p>
<div id="scl_1" class="section level5">
<h5 class="hasAnchor">
<a href="#scl_1" class="anchor"></a>scl_1</h5>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">msdf</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67   0.8</span></code></pre></div>
<p>First, <code><a href="../reference/disjoint.html">disjoint()</a></code> added up the core items what created a sum-score. Subsequently, <code><a href="../reference/disjoint.html">disjoint()</a></code> watched out for the highest correlation between this sum-score and another <code>trust</code> variable in the data frame. It found <code>polpati</code>. Because <code>polpati</code>’s correlation with the sum score (its corrected item-total correlation) is higher than the specified stop criterion (<code>mrit_min = 0.55</code>) it was melted into the core. The new fragment is now a bundle of 3 Items: <code>eupalmnt</code>, <code>eucomisn</code>, and <code>polpati.</code> The same logic applies to the inclusion of the other variables (e.g., <code>fedgovt</code> et al.) and reveals the second step of the algorithmic procedure: Continue to collect new items from <code>df = trust</code>, until the correlation between the sum-score of the items in the fragment and any other item is less than your prespecefied <code>mrit_min.</code></p>
</div>
<div id="scl_2" class="section level5">
<h5 class="hasAnchor">
<a href="#scl_2" class="anchor"></a>scl_2</h5>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">msdf</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67   0.8</span></code></pre></div>
<p>Now let’s focus on <code>$scl_2</code>. <code>scl_2</code> should raise the question, why another two-item scale emerges. First, it seems as if the stop criterion did fail. The <code>mrit</code> value at the end of <code>scl_1</code> is <code>0.58</code>. But at the beginning of <code>scl_2</code> <code>mrit = 0.67</code>. What is going on here? Well, the algorithm forces <code><a href="../reference/disjoint.html">disjoint()</a></code> to build (and enrich) new fragments, like <code>scl_1</code>, as long as there are remaining items in your data set. More specifically, the algorithm stops only if (a) there is no variable that meets the inclusion criterion, or (b) it soaked up the last remaining variable in the data frame.</p>
<p>In addition, (a) also holds for the construction process of new fragments. But when the algorithm builds a new fragment in particular, it needs (b) at least two leftovers – because a single variable cannot make up a core. So again, <code><a href="../reference/disjoint.html">disjoint()</a></code> will not build (and enrich) new fragments at any costs. The necessary correlations need to be positive and higher than your prespecefied minimum value. That unmasks the last unique step of the disjoint scaling procedure: If the algorithm detects some remaining items in the data set that meet its specific requirements, it starts over again. Now we know why <code><a href="../reference/disjoint.html">disjoint()</a></code> started another two-item scale – the algorithm demanded it.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">msdf</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67   0.8</span></code></pre></div>
</div>
</div>
<div id="a-quick-summary" class="section level4">
<h4 class="hasAnchor">
<a href="#a-quick-summary" class="anchor"></a>A quick summary</h4>
<p>To sum up, you could test your understanding against the following question: Why is there <em>no</em> other variable in <code>scl_2</code>? Right, although there are 13 variables in the data frame, there is no other variable among them that meets the internally defined inclusion criterion (the sum-score of the whole fragment is greater than the preset <code>mrit_min</code>). As a consequence, <code><a href="../reference/disjoint.html">disjoint()</a></code> did not merge another variable into <code>{eupalmnt, eucomisn}</code>.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">msdf</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67   0.8</span></code></pre></div>
</div>
<div id="conclusion" class="section level4">
<h4 class="hasAnchor">
<a href="#conclusion" class="anchor"></a>Conclusion</h4>
<p>To conclude, let’s remind ourselves of <code><a href="../reference/disjoint.html">disjoint()</a></code>’s job description (building disjoint scale fragments). If you recap the last steps, you will find that <code><a href="../reference/disjoint.html">disjoint()</a></code> successfully did its job. In the output each variable (from <code>eupalmnt</code> to <code>tv</code>) is present in either <code>scl_1</code> or <code>scl_2</code> exactly once. To put it another way, there is no intersecting variable which overlaps in these two fragments.</p>
<blockquote>
<p><strong>Note</strong>: To ensure disjointedness, the functions exclude a variable after assigning it to a fragment. In advance of the upcoming section keep this result in mind.</p>
</blockquote>
</div>
</div>
<div id="print-msdf" class="section level3">
<h3 class="hasAnchor">
<a href="#print-msdf" class="anchor"></a>print.msdf()</h3>
<p>Before we try to overlap the disjointedly built fragments, we should reprint the primary output. The following snippet does this though a little different. As you can see, I explicitly wrapped the expression in <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> and set the <code>digits</code> argument. In the R side note below I will explain why.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Pint output to n decimal places (default=2)</span>
<span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">msdf</span>, digits <span class="op">=</span> <span class="fl">3</span><span class="op">)</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                     mrit  rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.918 0.918 0.957</span>
<span class="co">#&gt; polpati            0.635 0.721 0.886</span>
<span class="co">#&gt; fedgovt            0.677 0.667 0.889</span>
<span class="co">#&gt; bundtag            0.699 0.641 0.899</span>
<span class="co">#&gt; judsyst            0.579 0.588 0.895</span>
<span class="co">#&gt; fccourt            0.582 0.554 0.897</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;              mrit  rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.669 0.669 0.802</span></code></pre></div>
<blockquote>
<p><strong>Note</strong>: When calling <code>msdf</code> R internally wraps the expression in <code><a href="https://rdrr.io/r/base/print.html">print()</a></code>. Thus, <code>msdf</code> is a shortcut for <code><a href="https://rdrr.io/r/base/print.html">print(msdf)</a></code>. Both methods can be used interchangeably. But if you want to set printing options (see <code><a href="https://rdrr.io/r/base/options.html">?option</a></code>) you need to explicitly call <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> with the desired option (e.g., <code>digits = 3</code>). Note, however, that I wrote custom function to print <code>msdf</code> objects. As a consequence,<code><a href="https://rdrr.io/r/base/print.html">print()</a></code> actually passes the work on to <code><a href="../reference/print.msdf.html">print.msdf()</a></code>. To get straight to the point, <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> owns a nice way to print the result to a specified number of digits, so I equipped <code><a href="../reference/print.msdf.html">print.msdf()</a></code> with that feature as well. The default is set to <code>2</code>. But be aware of the fact that omitting tons of decimal places does not mean the result is accurately rounded to the specified ones. Anyway, I decided to avoid rounding in the result. The reason therefor is R’s (as I find it, deeply confusing) rounding standard – IEC 60559 (see <code><a href="https://rdrr.io/r/base/Round.html">?round</a></code>). So, if you get into the situation where you need to report more than two decimal places, expand the result using <code>digits = n</code> and choose whatever standard you like.</p>
</blockquote>
</div>
<div id="overlap" class="section level3">
<h3 class="hasAnchor">
<a href="#overlap" class="anchor"></a>overlap()</h3>
<p>In this chapter we use the overlapping scaling procedure to extend out disjointedly built fragments. That is the job ob <code><a href="../reference/overlap.html">overlap()</a></code>. Therefore, we first need to learn about <code>mrit_min</code> (again). This will open up <code><a href="../reference/overlap.html">overlap()</a></code>’s hood. After that we will continue with a closer look inside its machinery.</p>
<blockquote>
<p><strong>Tip</strong>: When you want to know, if a given object is a <code>msdf</code> use <code><a href="../reference/is.msdf.html">is.msdf()</a></code>. Type <code><a href="../reference/is.msdf.html">?is.msdf</a></code> for more details.</p>
</blockquote>
<div id="mrit_min-again" class="section level4">
<h4 class="hasAnchor">
<a href="#mrit_min-again" class="anchor"></a>mrit_min (again)</h4>
<p>Let’s resume and try to extend the disjointedly built fragments. To do that, we (re-)consider the inclusion of every item in the data set that is not yet part of a given fragment (simply because of <code><a href="../reference/disjoint.html">disjoint()</a></code>’s nature). As a consequence, we will overcome <code><a href="../reference/disjoint.html">disjoint()</a></code>’s disjointedness. The following two paragraphs will lay out this idea in much greater detail. But for now, let’s jump straight into action. Oh before we start, just a word on the stop criterion.</p>
<p>With <code><a href="../reference/disjoint.html">disjoint()</a></code> we use a high value for the stop criterion to smash the scale. Now we use it to soak up up additional items from (what we will later call) the counterpart. Leave aside the counterpart for now. Remember the description of <code>mrit_min</code> instead. <code>mrit_min</code>is the definition of a fragment’s lower boundary and ranges between 0 and 1. This is also true for <code><a href="../reference/overlap.html">overlap()</a></code> (type <code><a href="../reference/overlap.html">?overlap</a></code>). What changes for the additional <code>mrit_min</code> is, it defines the limit under which you are not be willing to accept an item to <em>complete</em> an emerging <em>scale</em>. What does that means in practical terms? Well, deregulate <code><a href="../reference/overlap.html">overlap()</a></code>’s <code>mrit_min</code> – to allow <code><a href="../reference/overlap.html">overlap()</a></code> to soak up additional items from your data set. In the following snippet I stick with <code>mrit_min = 0.4</code>. But feel free to noodle around with this value. This helps you to fully understand <code>mrit_min</code>’s behavior within <code><a href="../reference/overlap.html">overlap()</a></code>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">mosdf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/overlap.html">overlap</a></span><span class="op">(</span><span class="va">msdf</span>, mrit_min <span class="op">=</span> <span class="fl">0.4</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; police             0.52 0.52  0.90</span>
<span class="co">#&gt; newsppr            0.52 0.49  0.90</span>
<span class="co">#&gt; tv                 0.52 0.47  0.90</span>
<span class="co">#&gt; uni                0.49 0.45  0.90</span>
<span class="co">#&gt; munadmin           0.47 0.43  0.90</span>
<span class="co">#&gt; healserv           0.42 0.40  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67  0.80</span>
<span class="co">#&gt; polpati     0.48 0.51  0.76</span>
<span class="co">#&gt; eucomisn    0.57 0.49  0.80</span>
<span class="co">#&gt; eupalmnt    0.73 0.53  0.85</span>
<span class="co">#&gt; fedgovt     0.67 0.53  0.87</span>
<span class="co">#&gt; bundtag     0.69 0.53  0.89</span>
<span class="co">#&gt; judsyst     0.58 0.51  0.89</span>
<span class="co">#&gt; fccourt     0.57 0.49  0.90</span>
<span class="co">#&gt; police      0.52 0.47  0.90</span>
<span class="co">#&gt; uni         0.49 0.45  0.90</span>
<span class="co">#&gt; munadmin    0.47 0.43  0.90</span>
<span class="co">#&gt; healserv    0.42 0.40  0.90</span></code></pre></div>
</div>
<div id="under-overlaps-hood" class="section level4">
<h4 class="hasAnchor">
<a href="#under-overlaps-hood" class="anchor"></a>Under overlap()’s hood</h4>
<p>The output reveals the news: <code><a href="../reference/overlap.html">overlap()</a></code> added a couple of variables to <code><a href="../reference/disjoint.html">disjoint()</a></code>’s fragments. But what happened inside the machinery? Well, first <code><a href="../reference/overlap.html">overlap()</a></code> found all items in the data frame that were not part of the given fragment. Let’s call that bundle its counterpart. Think of the counterpart as all variables in the specified data frame minus the items within the fragment. Accordingly, for <code>scl_1</code>, the counterpart is made up of <code>newsppr</code>, <code>tv</code>, <code>healserv</code>, <code>munadmin</code>, <code>uni</code> and <code>police</code>. The second step was merely a repetition. <code><a href="../reference/overlap.html">overlap()</a></code> started the previously described scaling procedure in each case over again. It thus continuously enriched each fragment with the according items from the counterpart – as long as the correlation between the sum-score of all items and any other item was higher than the specified <code>mrit_min = 0.4</code>. To put it another way, <code><a href="../reference/overlap.html">overlap()</a></code> takes the disjoint fragments as its basis when trying to extend each of them. That is why the default option is called <code>overlap_with = "fragments"</code>.</p>
<blockquote>
<p><strong>Note</strong>: Additionally, <code><a href="../reference/overlap.html">overlap()</a></code> provides the option to choose only the highest positively correlating pair of each scale fragment (<code>overlap_with = "core"</code>). Type <code><a href="../reference/overlap.html">?overlap</a></code> for more details.</p>
</blockquote>
<div id="a-small-excursion" class="section level5">
<h5 class="hasAnchor">
<a href="#a-small-excursion" class="anchor"></a>A small excursion</h5>
<p>Let me cite one additional result in form of a question. Did you realize that both fragments (<code>$scl_1</code> and <code>$scl_2</code>) include exactly the same variables? The scales did actually replicate. This hints to unidimensionality. For more on this consult the reference section.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>msdf <span class="op">=</span> <span class="va">mosdf</span><span class="op">$</span><span class="va">scl_1</span>, mosdf <span class="op">=</span> <span class="va">mosdf</span><span class="op">$</span><span class="va">scl_2</span><span class="op">)</span>, <span class="va">colnames</span><span class="op">)</span>
<span class="co">#&gt; $msdf</span>
<span class="co">#&gt;  [1] "eupalmnt" "eucomisn" "polpati"  "fedgovt"  "bundtag"  "judsyst" </span>
<span class="co">#&gt;  [7] "fccourt"  "police"   "newsppr"  "tv"       "uni"      "munadmin"</span>
<span class="co">#&gt; [13] "healserv"</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $mosdf</span>
<span class="co">#&gt;  [1] "newsppr"  "tv"       "polpati"  "eucomisn" "eupalmnt" "fedgovt" </span>
<span class="co">#&gt;  [7] "bundtag"  "judsyst"  "fccourt"  "police"   "uni"      "munadmin"</span>
<span class="co">#&gt; [13] "healserv"</span></code></pre></div>
</div>
</div>
<div id="a-quick-summary-1" class="section level4">
<h4 class="hasAnchor">
<a href="#a-quick-summary-1" class="anchor"></a>A quick summary</h4>
<p>All right, let’s pull it all together now. From the last two outputs you might have already guessed the bread and butter of <code><a href="../reference/overlap.html">overlap()</a></code>’s operating principles. The function enhances the disjoint scaling approach by gradually applying its underlying algorithm to multiple disjoint fragments. For the extension itself the function considers only items from the according counterpart. That is what we have seen so far. But now we need to move on and further discuss the emergence of the duplicates across scales.</p>
<div id="multiple-memberships-duplicates-across-scales" class="section level5">
<h5 class="hasAnchor">
<a href="#multiple-memberships-duplicates-across-scales" class="anchor"></a>Multiple memberships – duplicates across scales</h5>
<p>Let me present the key idea in a nutshell: Even if a particular item is already part of <code>scl_1</code> it still meets the preset inclusion criterion in <code>scl_2</code>. So why not tagging it relevant for the developing scale, too? Well, that is precisely what <code><a href="../reference/overlap.html">overlap()</a></code> does. This insight is twofold. (1) It points out the key mechanism when setting <code>mrit_min</code>: The more fragments <code><a href="../reference/disjoint.html">disjoint()</a></code> produces the more reason you give <code><a href="../reference/overlap.html">overlap()</a></code> to pick up on (and expand) those pieces. It now goes without saying that we use only reasonable items for the extension (i.e., those items from the counterpart which meet the inclusion requirements). (2) We could actually overcome <code><a href="../reference/disjoint.html">disjoint()</a></code>’s disjointedness. If this sounds like science-fiction talk visit the references for more background.</p>
</div>
</div>
<div id="conclusion-1" class="section level4">
<h4 class="hasAnchor">
<a href="#conclusion-1" class="anchor"></a>Conclusion</h4>
<p>The last last steps made us stumble upon a real benefit of this approach. The achievement is best documented in the previous example: The scales replicated. The reason is, Exploratory Likert Scaling does <em>not</em> induce differences as natural part of the procedure itself. To put it another way, although <code><a href="../reference/disjoint.html">disjoint()</a></code> smashes a data set, <code>elisr</code> provides a way out of the self-induced disjointedness – <code><a href="../reference/overlap.html">overlap()</a></code>. That is why <code><a href="../reference/overlap.html">overlap()</a></code> is not only a possibility to explore how the scales reunite, but a way to monitor how each scale evolve.</p>
</div>
</div>
<div id="an-all-in-one-snippet" class="section level3">
<h3 class="hasAnchor">
<a href="#an-all-in-one-snippet" class="anchor"></a>An all-in-one snippet</h3>
<p>What we know so far is that, even though we crushed the list of items using <code><a href="../reference/disjoint.html">disjoint()</a></code>, we permitted <code><a href="../reference/overlap.html">overlap()</a></code> to further process it. Note, that if we forced the fragments to be different beforehand, we would have masked the replication discovery itself. See the references for more on this. Breaking and reuniting often goes hand in hand, therefor we should learn how to combine the use of <code><a href="../reference/disjoint.html">disjoint()</a></code> and <code><a href="../reference/overlap.html">overlap()</a></code> next.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">msdf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/overlap.html">overlap</a></span><span class="op">(</span>
  <span class="fu"><a href="../reference/disjoint.html">disjoint</a></span><span class="op">(</span>df <span class="op">=</span> <span class="va">trust</span>, mrit_min <span class="op">=</span> <span class="fl">0.55</span><span class="op">)</span>,
  mrit_min <span class="op">=</span> <span class="fl">0.4</span>
<span class="op">)</span></code></pre></div>
</div>
</div>
<div id="further-analysis-of-the-trust-items" class="section level2">
<h2 class="hasAnchor">
<a href="#further-analysis-of-the-trust-items" class="anchor"></a>Further analysis of the trust items</h2>
<p>In everyday research, one will usually fall over reversed items. Such variables are broadly used to diminish response bias and reveal themselves generally through a negative correlation in the correlation matrix. Because there are no reversed variables in <code>trust</code> we need to make up an artificial one.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ntrust</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/with.html">within</a></span><span class="op">(</span><span class="va">trust</span>, <span class="va">uni</span> <span class="op">&lt;-</span> <span class="fl">8</span> <span class="op">-</span> <span class="va">uni</span><span class="op">)</span></code></pre></div>
<p>What this code does, is to subtract 8 from each value in <code>uni</code>, reassign it and store the result in a new data frame called <code>ntrust</code>. From here, we can start all over again using our all-in-one snippet. The only thing we need to add is <code>negative_too = TRUE</code> and specify the start- and endpoint of the scale (as a two element vector <code><a href="https://rdrr.io/r/base/c.html">c(1,7)</a></code>). But before we start, a word on the upcoming gambit: First, we should try replicate the results from the previous analysis to understand the machinery. Then, we can soften the regulations to become aware of the gained flexibility. But let’s move in a smoothed pace one step at the time.</p>
<div id="negative_too-true-sclvals" class="section level4">
<h4 class="hasAnchor">
<a href="#negative_too-true-sclvals" class="anchor"></a>negative_too = TRUE &amp; sclvals</h4>
<p>To repeat the previous results, we need to re-reverse <code>uni</code>. <code><a href="../reference/disjoint.html">disjoint()</a></code> lends you a hand with that. There are two arguments you need to manipulate (see <code><a href="https://rdrr.io/r/base/args.html">args(disjoint)</a></code>): Set (1) <code>negative_too = TRUE</code> and (2) <code>sclvals</code>. <code>sclvals</code> catches the start- and endpoint of your set of items. For example, the <code>trust</code> data set ranges between <span class="math inline">\(1\)</span> (no trust at all) and <span class="math inline">\(7\)</span> (great deal of trust). In practice, this means: <code>sclvals = c(1,7)</code>.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">d</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/disjoint.html">disjoint</a></span><span class="op">(</span><span class="va">ntrust</span>, mrit_min <span class="op">=</span> <span class="fl">0.55</span>, negative_too <span class="op">=</span> <span class="cn">TRUE</span>, sclvals <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">7</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; disjoint() didn't reverse an item.</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67   0.8</span></code></pre></div>
<p><code><a href="../reference/disjoint.html">disjoint()</a></code> did not reverse an item? Right, that move was a bit unfair. But as we know from prior analyses, <code>uni</code> is not included in any of <code><a href="../reference/disjoint.html">disjoint()</a></code>’s fragments. So we should actually not expect <code><a href="../reference/disjoint.html">disjoint()</a></code> to reverse it. However, if <code>uni</code> is not part a fragment it might be soaked up with <code><a href="../reference/overlap.html">overlap()</a></code>. So let’s move on. Because we stored the <code><a href="../reference/disjoint.html">disjoint()</a></code>’s result in <code>d</code>, we can simply stick it into <code><a href="../reference/overlap.html">overlap()</a></code>. But do not forget to tell <code><a href="../reference/overlap.html">overlap()</a></code> that it has permission to include reversed items. For convenience, you don’t need to specify <code>sclvals</code> twice. <code><a href="../reference/overlap.html">overlap()</a></code> remembers the start- and endpoint you set with <code><a href="../reference/disjoint.html">disjoint()</a></code> (see <code>attributes(d)$sclvals</code>).</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="../reference/overlap.html">overlap</a></span><span class="op">(</span><span class="va">d</span>,
        <span class="co"># Note: overlap() remembers the scaling values from disjoint()</span>
        mrit_min <span class="op">=</span> <span class="fl">0.4</span>, negative_too <span class="op">=</span> <span class="cn">TRUE</span>, sclvals <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">7</span><span class="op">)</span>
<span class="op">)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; overlap() reversed the following item(s):</span>
<span class="co">#&gt; - uni</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; police             0.52 0.52  0.90</span>
<span class="co">#&gt; newsppr            0.52 0.49  0.90</span>
<span class="co">#&gt; tv                 0.52 0.47  0.90</span>
<span class="co">#&gt; uni                0.49 0.45  0.90</span>
<span class="co">#&gt; munadmin           0.47 0.43  0.90</span>
<span class="co">#&gt; healserv           0.42 0.40  0.90</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $scl_2</span>
<span class="co">#&gt;             mrit rbar alpha</span>
<span class="co">#&gt; newsppr, tv 0.67 0.67  0.80</span>
<span class="co">#&gt; polpati     0.48 0.51  0.76</span>
<span class="co">#&gt; eucomisn    0.57 0.49  0.80</span>
<span class="co">#&gt; eupalmnt    0.73 0.53  0.85</span>
<span class="co">#&gt; fedgovt     0.67 0.53  0.87</span>
<span class="co">#&gt; bundtag     0.69 0.53  0.89</span>
<span class="co">#&gt; judsyst     0.58 0.51  0.89</span>
<span class="co">#&gt; fccourt     0.57 0.49  0.90</span>
<span class="co">#&gt; police      0.52 0.47  0.90</span>
<span class="co">#&gt; uni         0.49 0.45  0.90</span>
<span class="co">#&gt; munadmin    0.47 0.43  0.90</span>
<span class="co">#&gt; healserv    0.42 0.40  0.90</span></code></pre></div>
<blockquote>
<p><strong>Note</strong>: I tried to design both functions to act very user-friendly. <code><a href="../reference/disjoint.html">disjoint()</a></code> and <code><a href="../reference/overlap.html">overlap()</a></code> will both let you know, if they reverse a variable. And if so, which one.</p>
</blockquote>
</div>
</div>
<div id="another-made-up-but-auto-didactic-example" class="section level2">
<h2 class="hasAnchor">
<a href="#another-made-up-but-auto-didactic-example" class="anchor"></a>Another made up (but auto-didactic) example</h2>
<p>In the following snippet I reversed a core item of the second fragment. Make predictions of what will happen and why. Keep them in mind and see if they match the following output.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ntrust</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/with.html">within</a></span><span class="op">(</span><span class="va">trust</span>, <span class="va">tv</span> <span class="op">&lt;-</span> <span class="fl">8</span> <span class="op">-</span> <span class="va">tv</span><span class="op">)</span>

<span class="fu"><a href="../reference/overlap.html">overlap</a></span><span class="op">(</span>
  <span class="fu"><a href="../reference/disjoint.html">disjoint</a></span><span class="op">(</span><span class="va">ntrust</span>, mrit_min <span class="op">=</span> <span class="fl">0.55</span>, negative_too <span class="op">=</span> <span class="cn">TRUE</span>, sclvals <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">7</span><span class="op">)</span><span class="op">)</span>,
  mrit_min <span class="op">=</span> <span class="fl">0.4</span>, negative_too <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; disjoint() didn't reverse an item.</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; overlap() reversed the following item(s):</span>
<span class="co">#&gt; - tv</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; police             0.52 0.52  0.90</span>
<span class="co">#&gt; newsppr            0.52 0.49  0.90</span>
<span class="co">#&gt; tv                 0.52 0.47  0.90</span>
<span class="co">#&gt; uni                0.49 0.45  0.90</span>
<span class="co">#&gt; munadmin           0.47 0.43  0.90</span>
<span class="co">#&gt; healserv           0.42 0.40  0.90</span></code></pre></div>
</div>
<div id="different-types-of-scales" class="section level2">
<h2 class="hasAnchor">
<a href="#different-types-of-scales" class="anchor"></a>Different types of scales</h2>
<p>There are three different types of scales which <code><a href="../reference/disjoint.html">disjoint()</a></code> and <code><a href="../reference/overlap.html">overlap()</a></code> can handle. They all have in common that the underlying variables are real numeric vectors in R (either integers or objects of type <code>double</code>, see <code><a href="https://rdrr.io/r/base/typeof.html">?typeof</a></code>). If you enable the <code>negative_too = TRUE</code> option <code>elisr</code>’s wizards reverse:</p>
<ol style="list-style-type: decimal">
<li><p>Numeric scales starting at 1 (e.g., “1 2 3 4 5 6 7”). Both functions use the formula <span class="math inline">\((\max sclval + 1) - x\)</span> when setting <code>scalvals = c(1,7)</code> in this case.</p></li>
<li><p>Numeric scales starting at 0 (e.g., "0 1 2 3 4 5 6 7). The formula I used is <span class="math inline">\(\max sclval - x\)</span>. Set <code>sclvals = c(0,7)</code>.</p></li>
<li><p>Numeric scales starting below 0 (e.g., “-3 -2 -1 0 -1 -2 -3”). The workhorse bases simply on the formula <code>x * (-1)</code>. Set <code>sclvals = c(-3,3)</code>.</p></li>
</ol>
<p>In my experience, those three options cover a wide range of applications. Keep in mind, however, that the various input possibilities do not stop with the above-mentioned examples. The only thing holding you back is defined by the logic of the reversing rule itself. But within that range, you are free to enter whatever you like.</p>
</div>
<div id="handle-items-with-varying-start--and-endpoints" class="section level2">
<h2 class="hasAnchor">
<a href="#handle-items-with-varying-start--and-endpoints" class="anchor"></a>Handle items with varying start- and endpoints</h2>
<p>To be clear, <code>elisr</code> offers no way to tackle the start-endpoint issue internally. You have to face and overcome this obstacle yourself. But it is worth mentioning that neither <code><a href="../reference/overlap.html">overlap()</a></code> nor <code><a href="../reference/disjoint.html">disjoint()</a></code> will complain. They silently obey and apply the algorithm to the given list of variables.</p>
</div>
<div id="set-up-your-own-fragment" class="section level2">
<h2 class="hasAnchor">
<a href="#set-up-your-own-fragment" class="anchor"></a>Set up your own fragment</h2>
<p>Sometimes you will have a concrete idea of how a fragment looks like. In this case you want to predetermine the fragment and let <code><a href="../reference/overlap.html">overlap()</a></code> soak up additional variables afterward. Prespecifying the variables that form your fragment is straight forward. However, the steps you need to perform differ slightly from those used so far. If you want to predetermine a fragment, just pass the reduced version of your data frame to <code><a href="../reference/disjoint.html">disjoint()</a></code> – but now set <code>mrit_min = 0</code>. The second crux is to overwrite <code><a href="../reference/disjoint.html">disjoint()</a></code>’s data frame attribute with the full list of variables you want to do the overlap with. Hand the modified object over to <code><a href="../reference/overlap.html">overlap()</a></code> and that is it. If you are interested in why this additional step is necessary, read the note.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">frag</span> <span class="op">&lt;-</span> <span class="va">trust</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"tv"</span>, <span class="st">"bundtag"</span>, <span class="st">"fccourt"</span><span class="op">)</span><span class="op">]</span>
<span class="va">pre</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/disjoint.html">disjoint</a></span><span class="op">(</span>df <span class="op">=</span> <span class="va">frag</span>, mrit_min <span class="op">=</span> <span class="fl">0</span><span class="op">)</span>
<span class="co">#&gt; Warning: mrit_min = 0: fragment is pre-determined.</span>
<span class="co"># overlap() uses this attribute to build the counterpart</span>
<span class="fu"><a href="https://rdrr.io/r/base/attributes.html">attributes</a></span><span class="op">(</span><span class="va">pre</span><span class="op">)</span><span class="op">$</span><span class="va">df</span> <span class="op">&lt;-</span> <span class="va">trust</span>
<span class="op">(</span><span class="va">msdf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/overlap.html">overlap</a></span><span class="op">(</span><span class="va">pre</span>, mrit_min <span class="op">=</span> <span class="fl">0.4</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                  mrit rbar alpha</span>
<span class="co">#&gt; fccourt, bundtag 0.58 0.58  0.74</span>
<span class="co">#&gt; tv               0.35 0.40  0.67</span>
<span class="co">#&gt; fedgovt          0.67 0.46  0.77</span>
<span class="co">#&gt; polpati          0.65 0.48  0.82</span>
<span class="co">#&gt; eucomisn         0.67 0.49  0.85</span>
<span class="co">#&gt; eupalmnt         0.75 0.51  0.88</span>
<span class="co">#&gt; judsyst          0.63 0.50  0.89</span>
<span class="co">#&gt; newsppr          0.58 0.49  0.90</span>
<span class="co">#&gt; police           0.52 0.47  0.90</span>
<span class="co">#&gt; uni              0.49 0.45  0.90</span>
<span class="co">#&gt; munadmin         0.47 0.43  0.90</span>
<span class="co">#&gt; healserv         0.42 0.40  0.90</span></code></pre></div>
<blockquote>
<p><strong>Note</strong>: By running <code><a href="../reference/disjoint.html">disjoint()</a></code> on a subset of trust items, the function memorizes <code>frag</code> from your call as its data frame attribute (see <code>attributes(pre)$df</code>). The moment you commission <code><a href="../reference/overlap.html">overlap()</a></code>, the function accesses <code><a href="../reference/disjoint.html">disjoint()</a></code>’s attributes. In this case <code><a href="../reference/overlap.html">overlap()</a></code> tries to evaluate <code>df = core</code>. Why? Remember that <code><a href="../reference/overlap.html">overlap()</a></code> needs an idea of the variables it has to consider for the extension. To find inspiration, it evaluates the <code>df</code> argument and separates the items within the given fragment from those left in the data frame. But because the variables in the fragment are equal to those in the data set, its counterpart is empty. In other words, there are no items to extend the fragment with. If we set this attribute manually however, we sneak in a bunch of new variables and thus instruct <code><a href="../reference/overlap.html">overlap()</a></code> to pick up items from the newly defined object (in this case <code>trust</code>).</p>
</blockquote>
<div id="warning" class="section level4">
<h4 class="hasAnchor">
<a href="#warning" class="anchor"></a>Warning</h4>
<p>Please be aware that predetermining fragments is an advanced application. It is a serious change in <code>elisr</code>’s internal mechanism, because you bypass a great bunch of internal security measures. So, assure that at least the predetermined variables are a real subset of the data frame you have planned to assign as an attribute.</p>
</div>
</div>
<div id="working-with-the-results" class="section level2">
<h2 class="hasAnchor">
<a href="#working-with-the-results" class="anchor"></a>Working with the results</h2>
<p>In the previous chapters I mentioned <code><a href="../reference/print.msdf.html">print.msdf()</a></code>. Remember, the idea was to make use of the fact, that R internally wraps <code>msdf</code> in <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> and intervene into this process. <code><a href="https://rdrr.io/r/base/print.html">print()</a></code> now passes the work on to the <code><a href="../reference/print.msdf.html">print.msdf()</a></code>, which presents the result as follows:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="op">(</span><span class="va">msdf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/overlap.html">overlap</a></span><span class="op">(</span>
        <span class="fu"><a href="../reference/disjoint.html">disjoint</a></span><span class="op">(</span><span class="va">ntrust</span>, mrit_min <span class="op">=</span> <span class="fl">0.55</span>, negative_too <span class="op">=</span> <span class="cn">TRUE</span>,
                 sclvals <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">7</span><span class="op">)</span><span class="op">)</span>,
        <span class="co"># Note: overlap() remembers the scaling values from disjoint()</span>
        mrit_min <span class="op">=</span> <span class="fl">0.4</span>, negative_too <span class="op">=</span> <span class="cn">TRUE</span>
<span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; disjoint() didn't reverse an item.</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; overlap() reversed the following item(s):</span>
<span class="co">#&gt; - tv</span>
<span class="co">#&gt; $scl_1</span>
<span class="co">#&gt;                    mrit rbar alpha</span>
<span class="co">#&gt; eupalmnt, eucomisn 0.92 0.92  0.96</span>
<span class="co">#&gt; polpati            0.64 0.72  0.89</span>
<span class="co">#&gt; fedgovt            0.68 0.67  0.89</span>
<span class="co">#&gt; bundtag            0.70 0.64  0.90</span>
<span class="co">#&gt; judsyst            0.58 0.59  0.90</span>
<span class="co">#&gt; fccourt            0.58 0.55  0.90</span>
<span class="co">#&gt; police             0.52 0.52  0.90</span>
<span class="co">#&gt; newsppr            0.52 0.49  0.90</span>
<span class="co">#&gt; tv                 0.52 0.47  0.90</span>
<span class="co">#&gt; uni                0.49 0.45  0.90</span>
<span class="co">#&gt; munadmin           0.47 0.43  0.90</span>
<span class="co">#&gt; healserv           0.42 0.40  0.90</span></code></pre></div>
<p>The question is, why am I telling you all this? Well, to work with the results you need to understand that what you see is <em>not</em> what you actually get. <code><a href="https://rdrr.io/r/base/print.html">print()</a></code>’s version of <code><a href="../reference/overlap.html">overlap()</a></code>’s and <code><a href="../reference/disjoint.html">disjoint()</a></code>’s output is truly a bunch of summary statistics applied to it (see <code><a href="../reference/print.msdf.html">?print.msdf</a></code>). To put it another way, <code><a href="../reference/disjoint.html">disjoint()</a></code>’s and <code><a href="../reference/overlap.html">overlap()</a></code>’s outcomes are hidden by this internal printing mechanism. But you can break through this process by addressing one of <code>msdf</code>’s elements directly. This procedure will reveal the internally sorted (and in this case partially reversed, plus extended) data list. To keep things organized, the following output shows only the first six values (see <code><a href="https://rdrr.io/r/utils/head.html">?head</a></code>) of <code>msdf</code>’s component one: <code>$scl_1</code>.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/head.html">head</a></span><span class="op">(</span><span class="va">msdf</span><span class="op">$</span><span class="va">scl_1</span><span class="op">)</span>
<span class="co">#&gt;   eupalmnt eucomisn polpati fedgovt bundtag judsyst fccourt police newsppr tv</span>
<span class="co">#&gt; 1        4        3       4       5       5       3       7      5       6  7</span>
<span class="co">#&gt; 2        4        4       1       2       4       3       5      5       4  3</span>
<span class="co">#&gt; 3        4        4       5       6       6       6       6      5       4  4</span>
<span class="co">#&gt; 4        3        3       3       3       3       3       4      3       1  1</span>
<span class="co">#&gt; 5        1        1       1       1       1       2       1      2       1  1</span>
<span class="co">#&gt; 6        5       NA       4       6       5       4       5      7       3  4</span>
<span class="co">#&gt;   uni munadmin healserv</span>
<span class="co">#&gt; 1   4        5        6</span>
<span class="co">#&gt; 2   5        5        5</span>
<span class="co">#&gt; 3   5        3        6</span>
<span class="co">#&gt; 4   3        3        6</span>
<span class="co">#&gt; 5   5        4        5</span>
<span class="co">#&gt; 6   4        7        5</span></code></pre></div>
<blockquote>
<p><strong>Note</strong>: There is one tiny thing I want to point out in addition. Look at <code>tv</code>. It is reversed now. Hence, the reversing process was successful. If you want to prove that, just compare the outcome to previous results in this section and you will see that they are identical (type: <code>overlap(disjoint(trust, mrit_min = 0.55), mrit_min = 0.4</code>). In a nutshell: <code><a href="../reference/disjoint.html">disjoint()</a></code> and <code><a href="../reference/overlap.html">overlap()</a></code> both keep the reversed form of their variables. This behavior is thought to make further analysis as convenient as possible.</p>
</blockquote>
<p>Further analysis of the result is mandatory, remember? That is why I made the functions translate the actual output into an object type most connecting packages can handle. My suggestion is a <code>data.frame</code>. To become aware of the <code>data.frame</code> inside <code>msdf</code>, type <code>msdf$scl_1</code> and we break through its inherent structure.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/class.html">class</a></span><span class="op">(</span><span class="va">msdf</span><span class="op">$</span><span class="va">scl_1</span><span class="op">)</span>
<span class="co">#&gt; [1] "data.frame"</span></code></pre></div>
<p>To make a final unequivocal statement on <code>elisr</code>’s results: What you really get from applying <code><a href="../reference/disjoint.html">disjoint()</a></code> and <code><a href="../reference/overlap.html">overlap()</a></code> is an intermediate. A good hint is <code>mrit</code>. <code>mrit</code> is, the <em>marginal</em> corrected item-total correlation. Remember what that means – the linear relationship between the sum score of the items in a fragment at some specific point of the scale development process and the item which is considered for admission. Hence, the output represents the construction from a bottom-up perspective. To put it another way, when building scales from scratch <code>mrit</code>, <code>rbar</code>, and <code>alpha</code> keep track of the development progress, summarizing the gradually emerging scales based on the principles of classical test theory. However, these results can differ significantly from a more comprehensive (reliability) analysis of the proposed scale(s). With this in mind, I will end the manual with a place to (re-)start.</p>
</div>
<div id="a-place-to-restart" class="section level2">
<h2 class="hasAnchor">
<a href="#a-place-to-restart" class="anchor"></a>A place to restart</h2>
<p>There are several options to continue. But the one which I find most appealing is part of the <code>psych</code> package. The object of desire is called <code>alpha()</code>. This neat function provides a bunch of helpful diagnostic information on the proposed scale(s). The snippet below checks if <code>psych</code> is present and gives advise on how to proceed. Just copy and run the code.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw">if</span> <span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/ns-load.html">requireNamespace</a></span><span class="op">(</span><span class="st">"psych"</span>, quietly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span>
  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"`psych` is present. Ready to go!\n"</span><span class="op">)</span>
<span class="op">}</span> <span class="kw">else</span> <span class="op">{</span>
  <span class="fu"><a href="https://rdrr.io/r/base/cat.html">cat</a></span><span class="op">(</span><span class="st">"Please install the psych package to continue, type:\n"</span><span class="op">)</span>
  <span class="fu"><a href="https://rdrr.io/r/base/message.html">message</a></span><span class="op">(</span><span class="st">"install.packages('psych')"</span><span class="op">)</span>
<span class="op">}</span>
<span class="co">#&gt; `psych` is present. Ready to go!</span></code></pre></div>
<p>Once you have installed and loaded <code>psych</code>, there are two additional things you need to do. First, store the result of the exploratory analysis into an object of your choice. Second, hand the proposed scale over to <code>alpha()</code>. That is basically it. Since <code>msdf</code> already offers a scale to analyze, let’s stick with it. Note that <code>alpha()</code>’s output is pretty extensive. That is why I suppressed the result. But if you run the code yourself, you will see the result in full length.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu">psych</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/psych/man/alpha.html">alpha</a></span><span class="op">(</span><span class="va">msdf</span><span class="op">$</span><span class="va">scl_1</span><span class="op">)</span></code></pre></div>
<p>As we have seen throughout the manual, an analysis with <code>elisr</code> often provides multiple suggestions (e.g., <code>$scl_1</code> <em>and</em> <code>$scl_2</code>). We should work out a solution for this scenario, too. I usually hack the result of <code><a href="../reference/overlap.html">overlap()</a></code> in <code><a href="https://rdrr.io/r/base/lapply.html">lapply()</a></code> and let <code>alpha()</code> do its job on all components of the modified list. Please note once more, that in the snippet below the full result will be present only if you run the code in your console.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">msdf</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/overlap.html">overlap</a></span><span class="op">(</span><span class="va">d</span>, mrit_min <span class="op">=</span> <span class="fl">0.4</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/lapply.html">lapply</a></span><span class="op">(</span><span class="va">msdf</span>, <span class="fu">psych</span><span class="fu">::</span><span class="va"><a href="https://rdrr.io/pkg/psych/man/alpha.html">alpha</a></span><span class="op">)</span></code></pre></div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by Steven Bißantz.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
