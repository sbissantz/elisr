% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{utils}
\alias{utils}
\alias{nme_muscldf}
\alias{calc_rbar}
\alias{calc_alpha}
\alias{calc_mrit}
\alias{extr_core}
\alias{extr_core_nms}
\alias{extreb_itms}
\alias{rvrs_var}
\alias{rvrs_note}
\title{A Set of Utility Functions}
\usage{
nme_muscldf(x)

calc_rbar(scl, use)

calc_alpha(scl, use)

calc_mrit(scl, use)

extr_core(scl)

extr_core_nms(scl)

extreb_itms(df, itm_nms)

rvrs_var(var, sclvals)

rvrs_note(msg, applicant)
}
\arguments{
\item{x}{a muscldf}

\item{scl}{a scale from a muscldf}

\item{use}{an optional string indicating how to deal with missing values if
necessary. See \code{use} in \code{\link[stats]{cor}} for details.}

\item{df}{a data frame object,}

\item{itm_nms}{the names of an item from a scale.}

\item{var}{a variable or item (often a column from a data frame)}

\item{sclvals}{the start and end point of a scale (consider \code{c(sp,ep)})}
}
\description{
A Set of Utility Functions
}
\details{
\code{nme_muscldf} designates the components of a muscldf (e.g.,
  `scl_1`).

  \code{calc_rbar} calculates the average correlation between items from a
  gradually emerging scale.

  \code{calc_alpha} calculates Cronbachs alpha of a given set of items from
  the gradually emerging scale.

  \code{calc_mrit} calculates the corrected item-total correlation of an item
  with the sum score of all the other variables of the gradually emerging
  scale. That's why we call it marginal rit. Note that this procedure uses a
  part-whole correction. Thus the item itself is excluded in the calculation
  process.

  \code{extreb_itms} build up the counterpart of a fragment using its items
  names. Therefore the counterpart includes all variables that are not
  deliverd with the fragment but which are mentioned in the specified data
  set.

  \code{extr_core} extracts pairs of core items from a data frame. Those are
  part of a list of data frames nested within a `msdf` object. `overlap()`
  draws on this helper function when setting the `overlap_with=core` option.
  Hence, it forms for the actual overlap.

  \code{extr_core_nms} extracts the names of the core items in a given
  fragment (e.g. `scl_1`).

  \code{rvrs_var} reverses the item given the specified scaling values. It
  can handle the following types of scales:
  \itemize{
  \item  ...-3 -2 -1 0 1 2 3..., e.g., \code{sclvals = c(-3, 3)}
  \item  0 1 2 3 4 5 6..., e.g.,  \code{sclvals = c(0, 7)}
  \item  1 2 3 4 5 6 7..., e.g., \code{sclcals = c(1, 7)}
  }

  \code{rvrs_note} gets a report of variables `rvrs_var` recoded. Note
  however, that `rvrs_note` presentes this results only in a reduced form. To
  not overload the output it reports only a unique list of its notes.
}
