---
title: "Introduction to `musclr`" 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{musclr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(musclr)
```

`musclr` is a shortcut for "multiple scaling according to the principle of 
crystallization in R". The vignette is a step by step approach to teach, first 
and foremost, how to use `musclr`. In doing so (i.e., following the examples 
below) you will implicitly encounter some benefits of this exploratory 
procedure which primary lead to the development of this package. But if one
is ought for the full range of advantages, he or she might have a second look in 
the referenced paper. Let's summarize the introduction with the most important 
features.

#### Most important features 

* `musclr` offers a multiple scaling approach according to the principle 
  of crystallization for (quasi-)metrical data in R.

* It thus supports you in exploring multidimensional data structures. 

  Note: In common research practice one generally considers explorative factor
  analysis in this case often accepting rigid model assumptions (e.g.,
  orthogonality). 

* `musclr`, or rather its underlying algorithm, tries to bypass such inflexible 
  assumptions. 

* As a result the package provides a platform to maximize (a) the identification 
  of relevant dimensions, (b) allowing the scales to naturally correlate with 
  one another to accurately meet the actual conditions. 

 Hint: After exploratorily analyzing the data set with `disjoint()` and 
 `overlap()` you need to further process the result. Additional analysis in 
 mandatory. A solution on how to proceed is mentioned in the upcoming sections. 
 
## `disjoint()` &  `overlap()`

`musclr` basically consists of two functions: `disjoint()` and `overlap()`.
With a typical case in mind, the practical difference between them is: (1) You
will mainly use `disjoint()` to produce "sharp and disjoint" scale fragments.
Sharp and disjoint are those fragments, that include items which (a) share a
strong linear relationship with one another but (b) any of them "is tied" to a
single fragment. That's (2) where `overlap()` comes into play. Passing
fragments to `overlap()` the functions underlying algorithm tries to enrich
each fragment, by considering the inclusion of every item (from your specified
data frame) but those in the given fragment. Making a long story short: Using
`overlap()` an item can appear in more than one of the enriched fragments. In
doing so, one overcomes the splitting effect of the data frame induced by
`disjoint()`.

Note, that this reveals the key strategy of any exploratory analysis using
`musclr`: (1) Instruct `disjoint()` to produce a couple of "sharp", disjoint
scale fragments from your specified data frame. (2) Let `overlap()` "pick up
the pieces"; i.e. enrich the disjoint fragments considering those items that
are highly correlating (with the sum score of the given) fragment. A "how to"
will be presented right away.

### Analyzing the trust items

`trust` is a subset of the German General Social Survey (ALLBUS) 2018 in which
participants were asked about the trust they place in public institutions and
organizations. Use `?trust` for more details. Because the data frame is part of
`musclr`, we have easy access to them. Assuming you've already loaded the
package (e.g. using `library(musclr)`), let's instruct `disjoint()` to produce
a couple of sharp fragments of the trust items data.frame. In order to do that,
set a relatively high value for the marginal corrected item total correlation:
`mrit_min`. To cut things short, I'll use `.55` (mostly because this value
produced satisfactory results in prior analyses; a detailed explanation on how 
to use this value you'll find below).

```{r echo=TRUE}
library(musclr)
# `(foo <- baz)`: assign and print in one step
(msdf <-  disjoint(df = trust, mrit_min = .55))
```

What you should see in the output are two scale fragments `$scl_1` and
`$scl_2`.  Let's move through the output section step by step. First,
concentrate on `$scl_1`. What you'll notice is, the first line includes two
variables (`eupalmnt, eucomisn`). I'll call this the core of the fragment. The
core in this case is really nothing more than the (lineraly) highest
correlating pair chosen from an internally built correlation matrix of all
injected variables (i.e., the given data frame). `disjoint()` does this to
satisfy the first step of underlying algorithmic procedure of this multiple
scaling approach: Find the highest correlating pair. 

Note, however that neither `disjoint()` nor `overlap()` does this "at any
costs". The linear relationship between the core items must be greater than
your pre-set `mrit_min`. We could crosscheck that, looking in the line of the
core items focusing on `mrit` in the line of the core items: $mirt = 0.92$.
Remember: the value we set for the analysis was $mrit = .55$. Keep that in mind
if 

```{r}
mat <- replicate(5, rnorm(100))
df <- as.data.frame(mat)
disjoint(df, mrit_min = .2)
```






To tie in with above, what that means is that each variable
(`euparlament,...,fccourt`) is present in either `$scl_1` or `$scl_2` exactly
one time. To put it another way, there is no "intersecting" variable which
overlaps in these two scale fragments. To assure that that `disjoint()` excludes
each variable that have been assigned to a scale fragment. 






There is an easy
judgment heuristic on how to set this value: The more fragments the more reason
you'll give `overlap()` to soak up highly correlating items 

that might reproduce 

 



##

Mokken 
 
 
Mokken, R. J., 1971: A Theory and Procedure of Scale
Analysis. With Applications in Political Research. The
Hague/New York: Mouton.
 
 
 
 
Note: devalere the mjmisc (?) package in /Description since otherwise the package
doesnt run on CRAN 


