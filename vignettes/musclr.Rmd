---
title: "Introduction to `musclr`" 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{musclr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(musclr)
```

`musclr` is a shortcut for "multiple scaling according to the principle of 
crystallization in R". The vignette is a step by step approach to teach, first 
and foremost, how to use `musclr`. In doing so (i.e., following the examples 
below) you will implicitly encounter some benefits of this exploratory 
procedure which primary lead to the development of this package. But if one
is ought for the full range of advantages, he or she might have a second look in 
the referenced paper. Let's summarize the introduction with the most important 
features.

#### Most important features 

* `musclr` offers a multiple scaling approach according to the principle 
  of crystallization for (quasi-)metrical data in R.

* It thus supports you in exploring multidimensional data structures. 

  Note: In common research practice one generally considers explorative factor
  analysis in this case often accepting rigid model assumptions (e.g.,
  orthogonality). 

* `musclr`, or rather its underlying algorithm, tries to bypass such inflexible 
  assumptions. 

* As a result the package provides a platform to maximize (a) the identification 
  of relevant dimensions, (b) allowing the scales to naturally correlate with 
  one another to accurately meet the actual conditions. 

 Hint: After exploratorily analyzing the data set with `disjoint()` and 
 `overlap()` you need to further process the result. Additional analysis in 
 mandatory. A solution on how to proceed is mentioned in the upcoming sections. 
 
## `disjoint()` &  `overlap()`

`musclr` basically consists of two functions: `disjoint()` and `overlap()`. With
a typical case in mind, the practical difference between them is: (1) You will
mainly use `disjoint()` to produce "sharp & disjoint" scale fragments. "Sharp &
disjoint" are those fragments that include items that (a) share a strong linear
relationship but (b) any of them "is tied" to a single fragment. That's (2)
where `overlap()` comes into play. Passing fragments to `overlap()` the
functions underlying algorithm tries to enrich each fragment, by considering the
inclusion of every item (from your specified data frame) but those in the given
fragment. Making a long story short: Using `overlap()` an item can appear in
more than one of the enriched fragments. In doing so, one overcomes the
fragmentation of the data frame induced by `disjoint()`.

Note, that this reveals the key strategy of any exploratory analysis using
`musclr`: (1) Instruct `disjoint()` to produce a couple of "sharp", disjoint
scale fragments from your specified data frame. (2) Let `overlap()` "pick up the
pieces"; i.e. enrich the disjoint fragments considering those items that are
highly correlating (with the sumscore of the given) fragment. A "how to" will be
presented right away.

### Analyzing the trust items



```{r}


```



a high value in order to get
sharp scale fragments and th
 



##

Mokken 
 
 
Mokken, R. J., 1971: A Theory and Procedure of Scale
Analysis. With Applications in Political Research. The
Hague/New York: Mouton.
 
 
 
 
Note: devalere the mjmisc (?) package in /Description since otherwise the package
doesnt run on CRAN 


