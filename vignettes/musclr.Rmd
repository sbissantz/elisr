---
title: "A (more) technical companion for `musclr`" 
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{musclr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(musclr)
```

`musclr` is a shortcut for "multiple scaling according to the principle of 
crystallization in R". The vignette is a step by step approach to teach, first 
and foremost, how to use `musclr`. In doing so (i.e., following the examples 
below) you will implicitly encounter some benefits of this exploratory 
procedure which primary lead to the development of this package. But if one
is ought for the full range of advantages, he or she might have a second look in 
the referenced paper. Let's summarize the introduction with the most important 
features.

#### Most important features 

* `musclr` offers a multiple scaling approach according to the principle 
  of crystallization for (quasi-)metrical data in R.

* It thus supports you in exploring multidimensional data structures. 

  Note: In common research practice one generally considers explorative factor
  analysis in this case often accepting rigid model assumptions (e.g.,
  orthogonality). 

* `musclr`, or rather its underlying algorithm, tries to bypass such inflexible 
  assumptions in a bottom up manner. 

* As a result the package provides a platform to maximize (a) the identification 
  of relevant dimensions, (b) allowing the scales to naturally correlate with 
  one another to accurately meet the actual conditions. 

 Hint: After exploratorily analyzing the data set with `disjoint()` and 
 `overlap()` you need to further process the result. Additional analysis in 
 mandatory. A solution on how to proceed is mentioned in the upcoming sections. 
 
## `disjoint()` &  `overlap()`

`musclr` basically consists of two functions `disjoint()` and `overlap()`.
With a typical case in mind, the practical difference between them is: (1)
`disjoint` is set up to produce "sharp and disjoint" scale fragments.  Sharp
and disjoint are those fragments, that include items which (a) share a strong
linear relationship with one another but (b) any of them "is tied" to a single
fragment. That's (2) where `overlap()` comes into play. Passing fragments to
`overlap()` the functions underlying algorithm tries to enrich each fragment,
by considering the inclusion of every item (from your specified data frame) but
those in the given fragment. Making a long story short: Using `overlap()` an
item can appear in more than one of the enriched fragments. In doing so, one
overcomes the splitting effect of the data frame induced by `disjoint()`.

Note, that this already reveals the key strategy of any exploratory analysis
using this bottom up item selection procedure: (1) Instruct `disjoint()` to
produce a couple of sharp, disjoint scale fragments from your specified data
frame. (2) Let `overlap()` pick up the pieces; i.e. enrich the disjoint
fragments considering those items that are highly correlating with the (sum
score of the given) fragment. A detailed explanation on "how each functions
works" combined with a "how to use" will be presented right away.

### Analyzing the trust items using disjoint() and overlap()

`trust` is a subset of the German General Social Survey (ALLBUS) 2018 in which
participants answered some questions on the trust they place in public
institutions and organizations. Use `?trust` for more details. Because the data
frame is part of `musclr`, we have easy access to them. Assuming you've already
loaded and attached the package (e.g. with a `library(musclr)`), let's put
things into practice intially. In the first snippet we'll instruct `disjoint()`
to produce a couple of sharp fragments. In order to do that, set a relatively
high value for the marginal corrected item total correlation `mrit_min`. To
cut things short, I'll use `.55` (mostly because this value produced
satisfactory results in prior analyses (a more detailed explanation on how to
use this value you'll find below).

```{r echo=TRUE}
library(musclr)
# `(foo <- baz)`: assign and print in one step
(msdf <-  disjoint(df = trust, mrit_min = .55))
```

What you should see in the output are two scale fragments `$scl_1` and
`$scl_2`. If thats not the case, watch out for typos. A more general approach
is to read and understand the error message and fix it. Google is a good a place
to start. Let's move through the output section step by step.

#### disjoint()

First, concentrate on `$scl_1`. What you'll notice is, the first line includes
two variables (`eupalmnt, eucomisn`). I'll call this the core of the fragment.
The core in this case is the start of a two item scale. It includes the
(lineraly) highest positivly correlating pair chosen from an internally built
correlation matrix of all injected variables (i.e., the given data frame).
`disjoint()` does this to satisfy the first step of underlying algorithmic
procedure of this multiple scaling approach. As mentioned above: find the
highest correlating pair.

Note, however that neither `disjoint()` nor `overlap()` does this at any
costs. The linear relationship between the core items must be greater than
your pre-set `mrit_min` (Note: `disjoint()` will let you know, if that isn't the
case). But you could crosscheck by looking in the line of the core items,
focus on `mrit`: $mirt = 0.92$. Remember; the set value for the analysis
was $mrit = .55$. 

After disjoint has started the two point item scale (i.e. picked up the core
items) it tries to enrich it by one of the other variables in `df` (here:
`trust`). In this case it picked up `polpati`. The reason is straight forward:
the correlation between the sum score of {`eupalmnt` & `eucomisn`} and `polpati`
is still greater than the specified marginal corrected item total correlation
(`mrit_min`). Therefore the item is "melted" into the core. This new fragment is
now a bundle of 3 Items: `eupalament`, `eucomisn`, and `polpati.` The same
applies for `fedgovt` and reveals the important second step of the algorithmic
procedure: Continue to collect new items (and melt them into the fragement),
till the correlation between the sum score of the items (in the fragment) and
any other item is less than your pre-specified `mrit_min.` In summary, it
additionally collects the remaing three items you could see in the output
`bundtag`, `judsyst`, `fccourt`.

Moving along the lines in the output one might wonder, why there is another
scale with a `mrit_min` value greater than the pre-specified one. The
reason for this is that the algorithm tries to build (and enrich) fragments as
long as there are remaining variables in your variable list (`df`). More
specifially, the algorithm won't stop to enrich a fragment as long as there is
one variable left (in `trust`); and it won't interrupt constructing fragments as
long as there are at least two leftovers (and their correlations is positive and
greater than your pre-specified minimum value).  That betrays the last unique
step of this procedure: If there are variables left that meet the requirements,
start another two point item scale.

To conclude, one could guess why there is no other variable in `$scl_2`. Right,
because there are 13 variables in the data frame, there must have been no other
variable that meets the internally defined correlation criteria -- namely that
the sumscore of the whole fragment is greater than the pre-set $mrit_min$. As a
consequence, no other variable was considered to be merged with `{eupalmnt,
eucomisn}`. Double check in the last line of the given output.

Let's tie in with above and concentrate on both fragments now. If we remind
ourselves on the description of `disjoint()`s task (literally building disjoint
scale fragments), one can derieve from the previous explanation about its
construction, that it really did its job. In the output each variable
(`euparlament,...,tv`) is present in either `$scl_1` or `$scl_2` exactly once.
To put it another way, there is no "intersecting" variable which overlaps in
these two fragments. To assure that `disjoint()` excludes each variable after
assign it to a scale fragment.

#### overlap()

Before we'll try to enrich the disjoint fragments, we should recall the previous
results. A one-liner for this purpose is to type the name of the initialized
object we stored the results in. In the prior analysis that was `msdf`.

```{r}
# Show the disjoint scale fragments
msdf
# print(msdf, digits=2)
```
Note, that when calling `msdf` R usually wraps the expression in `print()`
internally. Thus, `msdf` is a shortcut for `print(msdf)`. But since I wrote a
custom function to print objects of the eponymous type `print()` actually passes
the work on to `print.msdf()`. This custom print function has an additional
argument called `digits`. Using `digits` you can edit the number of decimal
places for the result to display. The default is set to 2.

Let's resume and try to extend the scale with all items, despite those that are
already part of a pre-built disjoint scale. So what `overlap()` will acutally
do, is to (re-)consider the use of each item for a given fragment `disjoint()`
has not (simply because of its disjoint nature). The following paragraphs will
lay out this ideas in more detail.

```{r}
(mosdf <- overlap(msdf, mrit_min = .4))
# Equivalent formalization unmasking the defaults
# (mosdf <- overlap(msdf, mrit_min = .4), overlap_with="fragment" )
```

A quick overview reveals the overlap in the two fragments. But what happend
inside the machinerie? Well, first `overlap()` found all the items from the the
data frame (speficied with `disjoint()`) which were not part of the given
fragment in each case. Let's call this its counterpart. Secondly, it started the
previously described scaling procedure in each case over again. It thus
continuesly enriched each fragment with the according counterpart as long as the
correlation between the sum score of all items and any other item were less than
the specified `mrit_min` (reminder:`mrit.min=.4`). To put it another way,
`overlap()` took the disjoint fragments as its basis when trying to extend any
of them. That's why the default option is called `overlap_with="fragments"`.
Additionally, `overlap()` provides the option to choose only the highest
positively correalting pair of each scale fragment (`overlap_with="core"`). Type
`?overlap` for further details. To solidify the key insights, we should rework
the whole process on a more practical example again. Have a look on the result
of the previous functions call (`mosdf`). What you could see is that there are
two fragments `$scl_1`and `$scl_2`. At second glance they are pretty similar to
the result of `msdf`. Let's take $scl_1$ as an example.

```{r}
lapply( list( msdf=msdf$scl_1, mosdf=mosdf$scl_1 ), colnames )
# lapply( list( msdf=msdf$scl_2, mosdf=mosdf$scl_2 ), colnames )
```

That snippet shows the basis that `msdf` sets up through `disjoint()` for
`mosdf`. Likewise, one could say it demonstrates how `overlap()` extended this
fundament. Anyway, `overlap()` soaked up 6 additionl items from its counterpart
(`police`, ` newsppr`, `tv`, `uni`, `munadmin` & `healserv`). What happend here
algorithmically is, that `overlap()` searched for those items in `trust` that
were missing in `$scl_1`. Then, It used their intersection to build up this
counterpart. Subsequently, `overlap()` checked which correlation of these
variables with the sum score of the basic fragment is the greatest. If that
correlation exceeds the pre-set `mrit_min` it merged that variable into the
fragment. Finally, it starts over again considering the next item if it meets
these conditions. To conclude in more technical terms, those six additional
items tag the additional benefit we get from dissolving "`disjoint()`'s
genuin disjointness". 

There is one curcial step missing with regard to `$scl_2`. When `overlap()`
can't find any further item within a fragment that is worth considering it
continues; in this case `$scl_2`. So finally, what `overlap()` really is (well,
that's how I implemented it), is an enhancement of the disjoint scaling approach
by applying its underlying algorithm stepwise to multiple fragments considering
the according counterpart for their extension. This is what we see looping back
to the result of `overlap()`. There are two scaling fragments where some of the
items are present in both of them. I'll come to that in a moment. Let's clarify
the reason for that first. Even if a particular item is already part of $scl_1$
but nevertheless meets the pre-set admission criterion in `$scl_2`(the sum score
of the fragment and the corresponding item is greater $mrit_{min}=.4$) why not
tagging it as relevant for the developing scale? Note that `overlap()` will.

Now we can unfold the key mechanism when setting `mrit_min`: The more fragments
`disjoint()` produces the more reason one'll give `overlap()` to soak up
appropriate items from the corresponding counterparts. The key insight from
resolving `disjoint()`s disjointness (i.e. using `overlap()`) is that the scales
replicate. Check it against the result or type the follwing lines.

```{r}
lapply( list( scl_1=mosdf$scl_1, scl_2=mosdf$scl_2), 
        function(scl) sort(names(scl)))
```

To sum up, even if we break the list items appart using `disjoint()` we allow
`overlap()` to pick up -- and expand -- its pieces. That is one of the
advantages of this approach. It don't force these fragments to be different.
Although it smashes the induced list of variables, it allows to explore how the
individual parts reuinte. Forcing these scale fragments to be different would
have masked the replication discovery itself. Hence, the breaking and reuiniting
part of this algorithmic procedure (namely the combined use of `disjoint()` and
`overlap()`) are inseparably connected. For this reason, we should consider
their use in a single call.

#### An all in one snippet 

```{r}
msdf <- overlap(
  disjoint( df = trust, mrit_min = .55),
  mrit_min = .4
) 
print(msdf, digits=2)
```

### Further anlysis of the trust items -- including negative correlations

In everyday research, one will usually stumble upon reversed items. These items
are broadly used to diminish response bias and reveal themselves in gerneral
through a negative correlation in the correlation matrix. Since there are no
reversed variables in `trust` we need to make up an artifical one.

```{r}
ntrust <- within( trust, tv <- 8 - tv )
# Compare the results 
# cor(trust, use="pairwise.complete.obs")
# cor(ntrust, use="pairwise.complete.obs")
```

So what this code does, is to subtract $8$ from each value stored in the `uni`
variable, reassign it and store the result in a new data frame called `ntrust`.
From here we could start all over again using the all in one snippet. The only
thing we have to add is to set `negative_too=TRUE`and specify the start and
endpoint of the scale as a two element vector `c(1,7)`.

```{r}
ntrust <- within( trust, uni <- 8 - uni )
```

The first thing we should aim for is to replicate the results from the previous
analysis to understand the machinery and then soften the regularations to become
aware of the gained flexibility. But let's do this in a smoothed pace one step
at the time. To repeat the result from `disjoint()` we need to kind of
"re-reverse" `uni`. `disjoint()` does this for you, if you set the appropriate
options (`negative_too` & `sclvals`). 

```{r}
disjoint( ntrust, mrit_min=.55, negative_too=TRUE, sclvals=c(1,7) )
```
What we could see is that the results are identical to the former analysis
(using `trust` and `disjoint()`). We could now stick this result into
`overlap()`. Note however, that you have to tell `overlap()` it should include
negative correlations (otherwise it'll sticks only with positive ones). To save
some typing, I made `overlap()` remember the start and endpoint of the scale
you've passed to `disjoint()`. So no need to specify them twice. Let's use the
all in one snippet to replicate the prior results.

```{r}
overlap( 
        disjoint( ntrust, mrit_min=.55, negative_too = TRUE, sclvals=c(1,7) ),
        # Note: overlap() remembers the scaling values from disjoint()
        mrit_min = .4, negative_too=TRUE
)

```

### Counterfactual scenarios

Let's mess arround with some counterfactual scenarios and check the result on
real data. What would happen if we forbid `overlap()` to soak up negative items
as well? First of all, there should be no difference in the fragment which is
passed to `overlap()` because the code did not change. Thus, the basis for
overlap should stay the same in each case. But when soaking things up,
`overlap()` should now miss `uni` in both scales, because it has a negative
correlation. That is, what we'll see in the following result.


```{r}
overlap( 
        disjoint( ntrust, mrit_min=.55, negative_too = TRUE, sclvals=c(1,7) ),
        # Note: overlap() remembers the scaling values from disjoint()
        mrit_min = .4
)
```
The other scenario is, what would happen if we reverse the pattern. That means
we forbid `disjoint()` to collect negative item but allow `overlap()` to do so.
Well, now the basis could change. But if we remeber the basis of each fragment
`uni` weren't part of any of them. Hence, what we would expect is the same
result as with the complete re-reversing example right at the start. That is
what we'll see when executing the following lines. Note however, that this
behavior will change as parts of the basis are affacted (e.g., `tv`). See the
following chapter for further details.

```{r}
overlap( 
        disjoint( ntrust, mrit_min=.55 ),
        # Note: overlap() remembers the scaling values from disjoint()
        mrit_min = .4, negative_too = TRUE, sclvals=c(1,7)
)
```
### Differencees between reversing manually and automatically

There is a difference between reversing a variable before (manually) and within
the analysis (automatically). Let's reinitialize `ntrust` with `tv` to more
fully understand the machinerie. This is a variable we already know that it will
be part of the basis, on which `overlap()` expands on. If we follow the strategy
from the previous chapter, one might expect to replicate the result making
`disjoint()` and `overlap()` aware of negative items, when using the
`negative_too=TRUE` option in both cases. But as we could see that is not the
case.

```{r}
ntrust <- within( trust, tv <- 8 - tv )

overlap( 
        disjoint( ntrust, mrit_min=.55, negative_too = TRUE, sclvals=c(1,7) ),
        # Note: overlap() remembers the scaling values from disjoint()
        mrit_min = .4, negative_too = TRUE 
)
```
What have happend? There is a single restriction on building new cores one might
have probably not noticed yet: A core is the product of the two items with the
highest /positive/ correlation. Therefore, `tv` and  `newsppr` started a second
two-item scale in the prior analyises. They had the highest positive correlation
which fullfills the extension cirterion. The reverse is true for the association
between both of these variables in `ntrust`. In this case, `tv` and `newsppr`
share a strong negative relationship, when it comes to initiating another
two-item scale. As the restriction demands these association to be positive and
they are not, no further two-item scale is started. Accoridngly, you should be
aware this phenomenon when considering to manually invert these items. You
simply undermine this restriction.

Question: Does this assumption make sense? Almost equivalent data frames
produce different scaling results... This seems like madness.

NOTE: Write  "highest positive (!) correlation".





### Different scales

Cant handle 1..3 and 1...7 an general approach would be to being them on the kgV
and induce the 

## Working with the results



 



##

Mokken 
 
 
Mokken, R. J., 1971: A Theory and Procedure of Scale
Analysis. With Applications in Political Research. The
Hague/New York: Mouton.
 
 
 
 
Note: devalere the mjmisc (?) package in /Description since otherwise the package
doesnt run on CRAN 


